---
title: "Developing Bioinformatics Software: Continuous Integration"
author: Kelly Sovacool
date: last-modified
categories:
    - R
    - Python
    - Bioinformatics
    - Software Development
execute:
    eval: false
    echo: true
engine: knitr
---
<!--
:::: {.columns}

::: {.column}

R pkg
```{yaml}
#| filename: R ci.yml
name: build
```

:::

::: {.column}

Python pkg
```{yaml}
#| filename: Py ci.yml
name: build
```

:::

::::
-->
# A typical git workflow

The current best practice for using git to manage collaborative software
projects is known as 
[trunk-based development](https://www.atlassian.com/continuous-delivery/continuous-integration/trunk-based-development).
Under this model, small changes are frequently made in different branches, then
merged into the main "trunk" (i.e. the main or master branch) of the repo after
passing peer review. The steps look like this:

::: {.callout}
1. An issue is opened
    - a developer or user notices a bug, requests a feature, or asks a question.
1. Engage in the issue comments
    - to clarify the issue, ask for a reproducible example, etc.
1. Work on the issue
    1. create a new branch and switch to it.
    1. write tests that will pass when the issue is resolved.
    1. write or edit code to resolve the issue.
    1. (possibly) write more tests to make sure edge cases and failure modes are handled.
    1. write/update documentation if needed.
    1. make sure your tests pass and the package still builds.
1. Create a pull request
    1. assign or request a reviewer.
    1. the reviewer reviews your code.
    1. you make any requested changes.
    1. the reviewer approves your pull request once they're happy with it.
    1. merge the pull request.
1. Celebrate that you resolved an issue!
:::

You can have multiple issues open at any stage of the process at a time. 
You might start working on a feature, switch to fixing a time-sensitive bug and 
resolve it, then later go back to working on that feature.
Meanwhile, collaborators are working on other issues too!
This process enables highly collaborative and asynchronous work.

# Continuous integration + git = magic

It would be a bummer if you or a collaborator forgot a crucial step of the 
process, like running the unit tests or linting your code, and accidentally 
merged buggy/broken/bad code into the main branch of your project.
The good news is: You don't have to remember everything! Let the machines do it for you automatically!

**Continuous integration** is a practice where tests and other code quality checks 
are automatically run before code changes are merged into the main branch.

How does this modify our git workflow? When we open a pull request or push a 
commit to main, the CI service will run a workflow we define to run our checks,
so we don't have to do it manually!

::: {.callout}
### CI service options

- GitHub Actions
- Travis
- Jenkins
- CircleCI
- Azure DevOps
:::

We'll use GitHub Actions because it's easy to setup when you already have your 
repo hosted on GitHub, and they provide a lot of computing resources for free.

# Building a CI workflow with GitHub Actions

We're going to create a CI workflow that runs on all pushes and pull requests to
 the default branch (typically "main" or "master").
Workflows are defined with YAML files to specify how to configure the machine 
that runs the workflow, install dependencies, and run commands.

Let's start by creating a small workflow that prints "Hello, world!" and lists 
the files in the package.

I will demonstrate with two example packages: [bionitio-r](https://github.com/kelly-sovacool/bionitio-r) and [bionitio-python](https://github.com/kelly-sovacool/bionitio-python).

## Getting started with a simple action

Every Actions workflow resides in `.github/workflows/` and needs:

- `on` -- events that trigger the workflow
- `jobs` -- list of independent jobs each with `steps` to run in sequence.

```{yaml}
#| filename: .github/workflows/greet.yml

# name of the workflow
name: greet 

# when the workflow should run
on: 
  push:
    branches:
      - main
      - master
  pull_request:
    branches: 
      - main
      - master

# independent jobs in the workflow
jobs: 
  # this workflow just has one job called "greet"
  greet: 
    # the operating system to use for this workflow
    runs-on: ubuntu-latest 
    # list of steps in the workflow
    steps: 
      # use an action provided by github to checkout the repo
      - uses: actions/checkout@v3 
      
      # a custom step that runs a couple shell commands
      - name: List 
        run: |
            echo "listing files in the bioinitio directory"
            ls bionitio
      
      # a custom step that runs R code
      - name: Greet 
        run: print("Hello, world!")
        # Replace `shell: Rscript {0}` with `shell: python {0}` to run Python code instead!
        shell: Rscript {0}  


```

::: {.callout-tip}
## Create the "Hello world" action

1. Open an issue with the title "Set up continuous integration".
1. Switch to a new branch called `ci`.
1. Add this file to your repo at `.github/workflows/greet.yml`.
1. Replace `bionitio` with the name of your package.
1. Commit and push it to GitHub.
1. Finally, open a pull request from your new branch into main.
:::

Did your workflow run?
On GitHub, go to the Actions tab of your repo. 
Opening the pull request should have triggered the workflow to run.

Once the workflow finishes (about 15 seconds), it will either have a green 
checkmark (✅) for success or a red X (❌) for failure.

![](img/actions-greet.png)

**Click on the workflow run.** Then under 'jobs', **click on the job 'greet'.**
You're now viewing the log file for the job. 
You can click on the arrows to expand the details for each step.

![](img/actions-greet-job-log.png)

You can also see the status of the action from the Pull Request summary page.

::: {.callout-tip}
# `greet` status

In Slack, react with ✅ or ❌ to indicate the status of your workflow.
:::


## Test suite

This initial "hello world" workflow is cute, but not very useful. 
Let's edit the workflow to run our test suite for us automatically!

**R**: use `devtools::test()` to run just the tests, 
or `devtools::check()` to run all checks for CRAN.

```{yaml}
#| filename: R .github/workflows/ci.yml
name: CI

on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches: 
      - main
      - master

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
      R_KEEP_PKG_SOURCE: yes
    steps:
      - uses: actions/checkout@v3
      - uses: r-lib/actions/setup-r@v2
        with:
          use-public-rspm: true
      - uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: any::rcmdcheck
          needs: check
          working-directory: bionitio
      - name: Check
        uses: r-lib/actions/check-r-package@v2
        with:
          args: 'c("--no-manual", "--as-cran")'
          working-directory: bionitio

```

::: {.callout-note}
The r-lib actions assume that the top level of your repo is the same as the top 
level of your R package. If that's not the case, you'll need to specify the
`working-directory`. 

For my example project, `bionitio-r` is the top level of the git repo, and from
there the R package resides in `bionitio`:
```
bionitio-r
├── README.md
├── .github
│   └── workflows
│       └── ci.yml
├── bionitio
│   ├── DESCRIPTION
│   ├── R
│   │   ├── bionitio.R
│   │   └── file_utils.R
│   └── tests
│       ├── testthat
│       │   └── test-stats.R
│       └── testthat.R
```
:::

**Python**: use `pytest` to run the test suite.

```{yaml}
#| filename: Py .github/workflows/ci.yml
name: ci

on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python 3.11
      uses: actions/setup-python@v3
      with:
        python-version: "3.11"
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 pytest
        if [ -f requirements.txt ]; then 
            pip install -r requirements.txt
        fi
    - name: Test with pytest
      run: |
        pytest .
```


In each of these workflows, the action checks out the repo, installs R or Python, 
installs the dependencies of the package, then runs the tests.
If any of your tests fail, the whole actions workflow will fail too.

::: {.callout-tip}
## Testing with CI

Modify your CI workflow to run the test suite and push it. 
Does the CI workflow succeed or fail?

You may get failures if you haven't been running your unit tests as you develop
your code base. Take a few minutes to open issues for each test that failed.
:::

### Workflow status badges

Each Actions workflow has a status badge that indicates whether the action is
passing or failing. 
You may have come across status badges in GitHub README files of packages you use. 
Putting a CI status badge in the README file is a popular way for project 
maintainers to prominently display that CI is set up and it's working!

::: {.callout-tip}

### Add the workflow status badge to your README

Under the Actions tab, click the name of the workflow (e.g. `ci`), click the 
triple dots menu (`...`) in the upper right corner, and select `Create status badge`.

In the pop-up menu, click `Copy status badge Markdown`, paste it into your
README.md file, then commit and push your change.

**React to the slack message with ✅ when you're finished.**

:::

![](img/create-status-badge.png)

![](img/copy-status-badge-md.png){width=50%}

Now anyone who takes a look at your README file will see that your project uses
continuous integration!

### Code coverage

codecov is free for open source projects!

#### codecov status badge

## Lint and style code

- R: lintr & styler
- Python: flake8 & black

## Document

- R: roxygen2
- Python: sphinx

### Setup a documentation website

GitHub Pages will host your docs for free!

# Related topics & resources to explore

- Other ways to trigger workflows
    - on release
    - manual dispatch
    - cron schedule
- branch protection
    - prevent bad PRs from getting merged
- pre-commit hooks
    - run checks, style code, etc before you even commit