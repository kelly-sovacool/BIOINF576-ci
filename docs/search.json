[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "",
    "text": "The current best practice for using git to manage collaborative software projects is known as trunk-based development. Under this model, small changes are frequently made in different branches, then merged into the main â€œtrunkâ€ (i.e.Â the main or master branch) of the repo after passing peer review. The steps look like this:\n\n\n\n\n\n\n\nAn issue is opened\n\na developer or user notices a bug, requests a feature, or asks a question.\n\n\nEngage in the issue comments\n\nto clarify the issue, ask for a reproducible example, etc.\n\n\nWork on the issue\n\ncreate a new branch and switch to it.\nwrite tests that will pass when the issue is resolved.\nwrite or edit code to resolve the issue.\n(possibly) write more tests to make sure edge cases and failure modes are handled.\nwrite/update documentation if needed.\nmake sure your tests pass and the package still builds.\n\n\nCreate a pull request\n\nassign or request a reviewer.\nthe reviewer reviews your code.\nyou make any requested changes.\nthe reviewer approves your pull request once theyâ€™re happy with it.\nmerge the pull request.\n\n\nCelebrate that you resolved an issue!\n\n\n\n\nYou can have multiple issues open at any stage of the process at a time. You might start working on a feature, switch to fixing a time-sensitive bug and resolve it, then later go back to working on that feature. Meanwhile, collaborators are working on other issues too! This process enables highly collaborative and asynchronous work.\n\n\ngit + ci = magic âœ¨\n\nIt would be a bummer if you or a collaborator forgot a crucial step of the process, like running the unit tests or linting your code, and accidentally merged buggy/broken/bad code into the main branch of your project. The good news is: You donâ€™t have to remember everything! Let the machines do it for you automatically!\nContinuous integration is a practice where tests and other code quality checks are automatically run before code changes are merged into the main branch.\nHow does this modify our git workflow? When we open a pull request or push a commit to main, the CI service will run a workflow we define to run our checks, so we donâ€™t have to do it manually!\n\n\n\n\n\n\nCI service options\n\n\n\n\nGitHub Actions\nTravis\nJenkins\nCircleCI\nAzure DevOps\n\n\n\nWeâ€™ll use GitHub Actions because itâ€™s easy to setup when you already have your repo hosted on GitHub, and they provide a lot of computing resources for free."
  },
  {
    "objectID": "index.html#configure-actions-permissions",
    "href": "index.html#configure-actions-permissions",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "Configure Actions permissions",
    "text": "Configure Actions permissions\nBefore we can get started using GitHub Actions, weâ€™ll need to make sure we configure our repo settings to allow Actions to run and push changes.\n\n\n\n\n\n\nEnable Actions\n\n\n\nOn Github.com, go to your repository, click Settings and under â€˜Code and automationâ€™ click Actions -> General. Under â€˜Actions permissionsâ€™, select Allow all actions and reusable workflows and click Save.\n\n\n\n\n\n\n\n\n\nAllow Actions to read & write\n\n\n\nNext, scroll down to the bottom of the page. Under â€˜Workflow permissionsâ€™, select Read and write permissions and click Save.\n\n\n\nNow weâ€™re ready to start using GitHub Actions for our projects!"
  },
  {
    "objectID": "index.html#getting-started-with-a-simple-action",
    "href": "index.html#getting-started-with-a-simple-action",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "Getting started with a simple action",
    "text": "Getting started with a simple action\nEvery GitHub Actions workflow resides in .github/workflows/ and needs:\n\n\non â€“ events that trigger the workflow\n\njobs â€“ list of independent jobs each with steps to run in sequence.\n\n\nWorkflowÂ 1: .github/workflows/greet.yml\n# name of the workflow\nname: greet \n\n# when the workflow should run\non: \n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches: \n      - main\n      - master\n\n# independent jobs in the workflow\njobs: \n  # this workflow just has one job called \"greet\"\n  greet: \n    # the operating system to use for this workflow\n    runs-on: ubuntu-latest \n    # list of steps in the workflow\n    steps: \n      # use an action provided by github to checkout the repo\n      - uses: actions/checkout@v3 \n      \n      # a custom step that runs a couple shell commands\n      - name: List \n        run: |\n            echo \"listing files in the bioinitio directory\"\n            ls bionitio\n      \n      # a custom step that runs R code\n      - name: Greet \n        run: print(\"Hello, world!\")\n        # Replace `shell: Rscript {0}` with `shell: python {0}` to run Python code instead!\n        shell: Rscript {0}  \n\n\n\n\n\n\n\nCreate the â€œHello worldâ€ action\n\n\n\n\nOpen an issue with the title â€œSet up continuous integrationâ€.\nSwitch to a new branch called ci.\nAdd the workflow (WorkflowÂ 1) to your repo at .github/workflows/greet.yml.\nReplace bionitio with the name of your package.\nCommit and push it to GitHub.\nFinally, open a pull request from your new branch into main.\n\n\n\nDid your workflow run? On GitHub, go to the Actions tab of your repo. Opening the pull request should have triggered the workflow to run.\nOnce the workflow finishes (about 15 seconds), it will either have a green checkmark (âœ…) for success or a red X (âŒ) for failure.\n\nClick on the workflow run. Then under â€˜jobsâ€™, click on the job â€˜greetâ€™. Youâ€™re now viewing the log file for the job. You can click on the arrows to expand the details for each step.\n\nYou can also see the status of the action from the Pull Request summary page.\n\n\n\n\n\n\ngreet status\n\n\n\nIn Slack, react with âœ… or âŒ to indicate the status of your workflow."
  },
  {
    "objectID": "index.html#test-suite",
    "href": "index.html#test-suite",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "Test suite",
    "text": "Test suite\nThis initial â€œhello worldâ€ workflow is cute, but not very useful. Letâ€™s edit the workflow to run our test suite for us automatically!\nR: use devtools::test() to run just the tests, or devtools::check() to run all checks for CRAN.\nname: CI\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches: \n      - main\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n      R_KEEP_PKG_SOURCE: yes\n    steps:\n      - uses: actions/checkout@v3\n      - uses: r-lib/actions/setup-r@v2\n        with:\n          use-public-rspm: true\n      - uses: r-lib/actions/setup-r-dependencies@v2\n        with:\n          extra-packages: any::rcmdcheck\n          needs: check\n          working-directory: bionitio\n      - name: Check\n        uses: r-lib/actions/check-r-package@v2\n        with:\n          args: 'c(\"--no-manual\", \"--as-cran\")'\n          working-directory: bionitio\n\n\n\n\n\n\nNote\n\n\n\nThe r-lib actions assume that the top level of your repo is the same as the top level of your R package. If thatâ€™s not the case, youâ€™ll need to specify the working-directory.\nFor my example project, bionitio-r is the top level of the git repo, and from there the R package resides in bionitio:\nbionitio-r\nâ”œâ”€â”€ README.md\nâ”œâ”€â”€ .github\nâ”‚Â Â  â””â”€â”€ workflows\nâ”‚Â Â      â””â”€â”€ ci.yml\nâ”œâ”€â”€ bionitio\nâ”‚Â Â  â”œâ”€â”€ DESCRIPTION\nâ”‚Â Â  â”œâ”€â”€ R\nâ”‚Â Â  â”‚Â Â  â”œâ”€â”€ bionitio.R\nâ”‚Â Â  â”‚Â Â  â””â”€â”€ file_utils.R\nâ”‚Â Â  â””â”€â”€ tests\nâ”‚Â Â      â”œâ”€â”€ testthat\nâ”‚Â Â      â”‚Â Â  â””â”€â”€ test-stats.R\nâ”‚Â Â      â””â”€â”€ testthat.R\n\n\nPython: use pytest to run the test suite.\nname: ci\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python 3.11\n      uses: actions/setup-python@v3\n      with:\n        python-version: \"3.11\"\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install pytest\n        if [ -f requirements.txt ]; then \n            pip install -r requirements.txt\n        fi\n    - name: Test with pytest\n      run: |\n        pytest .\nIn each of these workflows, the action checks out the repo, installs R or Python, installs the dependencies of the package, then runs the tests. If any of your tests fail, the whole actions workflow will fail too.\n\n\n\n\n\n\nTesting with CI\n\n\n\nIn your ci branch, modify your CI workflow to run the test suite (R: ?@lst-cir, Python: ?@lst-cipy), then commit and push your changes. Does the CI workflow succeed or fail?\nYou may get failures if you havenâ€™t been running your unit tests as you develop your code base. Take a few minutes to open issues for each test that failed.\nReact to the slack message with âœ… when youâ€™re finished opening issues or now if the workflow completed successfully.\n\n\nWorkflow status badges\nEach Actions workflow has a status badge that indicates whether the action is passing or failing. You may have come across status badges in GitHub README files of packages you use. Putting a CI status badge in the README file is a popular way for project maintainers to prominently display that CI is set up and itâ€™s working!\n\n\n\n\n\n\nAdd the workflow status badge to your README\n\n\n\nUnder the Actions tab, click the name of the workflow (e.g.Â ci), click the triple dots menu (...) in the upper right corner, and select Create status badge.\nIn the pop-up menu, click Copy status badge Markdown, paste it into your README.md file, then commit and push your change on the ci branch.\nReact to the slack message with âœ… when youâ€™re finished.\n\n\n\n\nNow anyone who takes a look at your README file will see that your project uses continuous integration!"
  },
  {
    "objectID": "index.html#lint-and-style-code",
    "href": "index.html#lint-and-style-code",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "Lint and style code",
    "text": "Lint and style code\nMany large software projects follow a specific coding style guide to make sure their code base is consistent and easy to read.\n\nGood coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread.\nâ€“ The Tidyverse Style Guide\n\nA linter checks your code to make sure you conform to a style guide and raises warnings if your code doesnâ€™t conform. A code formatter or styler modifies your code to make it conform to a style guide. There is a lot of overlap in the problems that linters and formatters can catch, but linters additionally warn about not only style problems but more serious problems like syntax errors.\n\n\nlanguage\nlinter\nformatter\n\n\n\nR\nlinter\nstyler\n\n\nPython\nflake8\nblack\n\n\n\nWhen adding these tools to CI, make sure you run the formatter before the linter, so the linter will only complain about problems that the formatter canâ€™t fix. Since the code formatter modifies our code, we will also need to commit and push the code changes using the GitHub Actions bot as the author.\nname: CI\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\nenv:    # configure environment variables for git commits\n  actor: \"41898282+github-actions[bot]\"\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n      R_KEEP_PKG_SOURCE: yes\n    steps:\n      - uses: actions/checkout@v3\n      - uses: r-lib/actions/setup-r@v2\n        with:\n          use-public-rspm: true\n      - uses: r-lib/actions/setup-r-dependencies@v2\n        with:  # also install styler & lintr\n          extra-packages: any::rcmdcheck, any::styler, any::lintr\n          needs: check\n          working-directory: bionitio\n      - name: Configure git # use the environment variable we set above\n        run: |\n          git config --local user.email \"${actor}@users.noreply.github.com\"\n          git config --local user.name \"$actor\"\n      - name: Check\n        uses: r-lib/actions/check-r-package@v2\n        with:\n          args: 'c(\"--no-manual\", \"--as-cran\")'\n          working-directory: bionitio\n      - name: Style & lint\n        run: |\n            styler::style_dir(\".\")\n            lintr::lint_dir(\".\")\n        shell: Rscript {0}\n      - name: Commit and push changes\n        run: |\n          git add .\n          git commit -m \"ğŸ¨ Style code\" || echo \"No changes to commit\"\n          git push\nname: ci\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\nenv:    # configure environment variables for git commits\n  actor: \"41898282+github-actions[bot]\"\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python 3.11\n      uses: actions/setup-python@v3\n      with:\n        python-version: \"3.11\"\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install pytest black flake8 # also install black & flake8\n        if [ -f requirements.txt ]; then\n            pip install -r requirements.txt\n        fi\n    - name: Configure git  # use the environment variable we set above\n      run: |\n        git config --local user.email \"${actor}@users.noreply.github.com\"\n        git config --local user.name \"$actor\"\n    - name: Test\n      run: |\n        pytest .\n    - name: Format & tint\n      run: |\n        black . # first run black, then run flake8\n        flake8 --extend-ignore E203 --max-line-length 88 .\n    - name: Commit and push changes\n      run: |\n        git add .\n        git commit -m \"ğŸ¨ Style code\" || echo \"No changes to commit\"\n        git push\n\n\n\n\n\n\nNote\n\n\n\nflake8 is not 100% compatible with black by default. Here we direct flake8 to ignore one of its errors (--extend-ignore E203) and increase the maximum allowed line length (--max-line-length 88) to make flake8 compatible with black.\n\n\nThere are several key changes we made to this workflow to make sure our styling and linting would work:\n\nSet a global environment variable called actor with the username of the GitHub Actions bot.\nConfigure the git username and email to point to the GitHub Actions bot, using the environment variable we created in above.\nInstall additional dependencies for linting and formatting the code.\nRun the code formatter and linter.\nCommit any changes and push to origin.\n\n\n\n\n\n\n\nStyle & lint your code\n\n\n\nYou know the drill! Modify your workflow (R: ?@lst-r-style | Python: ?@lst-py-style) and see what happens when you push it to GitHub.\nDoes the linter raise any errors? If so, take a moment to open issues for the errors you need to fix. React to the slack message with âœ… when youâ€™re finished opening issues or now if youâ€™re code is already lint-free."
  },
  {
    "objectID": "index.html#document",
    "href": "index.html#document",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "Document",
    "text": "Document\n\nR: roxygen2\nPython: sphinx\n\nSetup a documentation website\nGitHub Pages will host your docs for free!"
  },
  {
    "objectID": "index.html#code-coverage",
    "href": "index.html#code-coverage",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "Code coverage",
    "text": "Code coverage\ncodecov is free for open source projects!\ncodecov status badge"
  }
]