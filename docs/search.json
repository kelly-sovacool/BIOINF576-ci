[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "",
    "text": "The current best practice for using git to manage collaborative software projects is known as trunk-based development. Under this model, small changes are frequently made in different branches, then merged into the main “trunk” (i.e. the main or master branch) of the repo after passing peer review. The steps look like this:\n\n\n\n\n\n\n\nAn issue is opened\n\na developer or user notices a bug, requests a feature, or asks a question.\n\n\nEngage in the issue comments\n\nto clarify the issue, ask for a reproducible example, etc.\n\n\nWork on the issue\n\ncreate a new branch and switch to it.\nwrite tests that will pass when the issue is resolved.\nwrite or edit code to resolve the issue.\n(possibly) write more tests to make sure edge cases and failure modes are handled.\nwrite/update documentation if needed.\nmake sure your tests pass and the package still builds.\n\n\nCreate a pull request\n\nassign or request a reviewer.\nthe reviewer reviews your code.\nyou make any requested changes.\nthe reviewer approves your pull request once they’re happy with it.\nmerge the pull request.\n\n\nCelebrate that you resolved an issue!\n\n\n\n\nYou can have multiple issues open at any stage of the process at a time. You might start working on a feature, switch to fixing a time-sensitive bug and resolve it, then later go back to working on that feature. Meanwhile, collaborators are working on other issues too! This process enables highly collaborative and asynchronous work. Making changes in separate branches and merging them into main only after testing and peer review helps ensure that only high quality code is adopted.\n\n\ngit + ci = magic ✨\n\nIt would be a bummer if you or a collaborator forgot a crucial step of the process, like running the unit tests or linting your code, and accidentally merged buggy/broken/bad code into the main branch of your project. The good news is: You don’t have to remember everything! Let the machines do it for you automatically!\nContinuous integration is a practice where tests and other code quality checks are automatically run before code changes are merged into the main branch.\nHow does this modify our git workflow? When we open a pull request or push a commit to main, the CI service will run a workflow we define to run our checks, so we don’t have to do it manually!\n\n\n\n\n\n\nCI service options\n\n\n\n\nGitHub Actions\nTravis\nJenkins\nCircleCI\nAzure DevOps\n\n\n\nWe’ll use GitHub Actions because it’s easy to setup, you’re alraedy using GitHub for your projects, and they provide a lot of computing resources for free."
  },
  {
    "objectID": "index.html#continuous-integration-what-why",
    "href": "index.html#continuous-integration-what-why",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "",
    "text": "git + ci = magic ✨\n\nIt would be a bummer if you or a collaborator forgot a crucial step of the process, like running the unit tests or linting your code, and accidentally merged buggy/broken/bad code into the main branch of your project. The good news is: You don’t have to remember everything! Let the machines do it for you automatically!\nContinuous integration is a practice where tests and other code quality checks are automatically run before code changes are merged into the main branch.\nHow does this modify our git workflow? When we open a pull request or push a commit to main, the CI service will run a workflow we define to run our checks, so we don’t have to do it manually!\n\n\n\n\n\n\nCI service options\n\n\n\n\nGitHub Actions\nTravis\nJenkins\nCircleCI\nAzure DevOps\n\n\n\nWe’ll use GitHub Actions because it’s easy to setup, you’re alraedy using GitHub for your projects, and they provide a lot of computing resources for free."
  },
  {
    "objectID": "index.html#configure-permissions",
    "href": "index.html#configure-permissions",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "Configure permissions",
    "text": "Configure permissions\nBefore we can get started using GitHub Actions, we’ll need to make sure we configure our repo settings to allow Actions to run and push changes.\n\n\n\n\n\n\nEnable Actions\n\n\n\nOn Github.com, go to your repository, click Settings and under ‘Code and automation’ click Actions -&gt; General. Under ‘Actions permissions’, select Allow all actions and reusable workflows and click Save.\n\n\n\n\n\n\n\n\n\nAllow Actions to read & write\n\n\n\nNext, scroll down to the bottom of the page. Under ‘Workflow permissions’, select Read and write permissions and click Save.\n\n\n\nNow we’re ready to start using GitHub Actions for our projects!"
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "Getting started",
    "text": "Getting started\nEvery GitHub Actions workflow resides in .github/workflows/ and needs:\n\n\non – events that trigger the workflow\n\njobs – list of independent jobs each with steps to run in sequence.\n\nsteps – each step specifies a third party action to uses with uses, or specifies shell code to run.\n\n\nWorkflow 1: .github/workflows/greet.yml\n# name of the workflow\nname: greet\n\n# when the workflow should run\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\n# independent jobs in the workflow\njobs:\n  # this workflow just has one job called \"greet\"\n  greet:\n    # the operating system to use for this workflow\n    runs-on: ubuntu-latest\n    # list of steps in the workflow\n    steps:\n      # use an action provided by github to checkout the repo\n      - uses: actions/checkout@v3\n      # a custom step that runs a couple shell commands\n      - name: List\n        run: |\n            echo \"listing files in the bioinitio directory\"\n            ls bionitio\n      # a custom step that runs R code\n      - name: Greet\n        run: print(\"Hello, world!\")\n        # Replace `shell: Rscript {0}` with `shell: python {0}` to run Python code instead!\n        shell: Rscript {0}\n\n\n\n\n\n\n\nCreate the “Hello world” action\n\n\n\n\n\nOpen an issue with the title “Set up continuous integration”.\n\n\n\n\n\n\nHint\n\n\n\n\n\nOn GitHub, go to the Issues tab and click New issue. Give your issue a descriptive title and description. \n\n\n\n\n\nSwitch to a new branch called ci.\n\n\n\n\n\n\nHint\n\n\n\n\n\nFrom a Unix terminal:\n\ncd path/to/your/project\ngit switch -c ci\n\n\n\n\n\n\nAdd the workflow to your repo at .github/workflows/greet.yml.\n\n\n\n\n\n\nHint\n\n\n\n\n\nMake the directories and create a blank YAML file.\n\nmkdir -p .github/workflows\ntouch .github/workflows/greet.yml\n\nOpen the file in your preferred text editor. e.g. for VS Code:\n\ncode .github/workflows/greet.yml\n\nPaste in Workflow 1\n\n\n\n\n\nReplace bionitio with the name of your package and save the workflow file.\n\n\n\n\n\n\nHint\n\n\n\n\n\nThe package subdirectory is referenced twice in the List step.\nDon’t forget to save the file after you edit it!\n\n\n\n\n\nCommit and push it to GitHub.\n\n\n\n\n\n\nHint\n\n\n\n\n\nStage the new file, commit the changes with a descriptive message, and push it to GitHub.\ngit add .github/workflows/greet.yml\ngit commit -m \"Create greet workflow\"\ngit push\n\n\n\n\n\nFinally, open a pull request from your new branch into main.\n\n\n\n\n\n\nHint\n\n\n\n\n\nOn GitHub, go the Pull requests tab and click Compare & pull request for the ci branch.\n\nGive the pull request (PR) a short and informative title. In the PR description, write Resolves # followed by the issue number you opened in Step 1.\n\nClick Create pull request. When you merge the PR later, it will automatically close the issue too.\n\n\n\n\n\n\n\nDid your workflow run?\nOn GitHub, go to the Actions tab of your repo. Opening the pull request should have triggered the workflow to run.\nOnce the workflow finishes (about 15 seconds), it will either have a green checkmark (✅) for success or a red X (❌) for failure.\n\nClick on the workflow run. Then under ‘jobs’, click on the job ‘greet’. You’re now viewing the log file for the job. You can click on the arrows to expand the details for each step.\n\nYou can also see the status of the action from the Pull Request summary page. Keep your pull request open. We’re going to continue pushing commits to the ci branch as we add new steps to the workflow.\n\n\n\n\n\n\ngreet status\n\n\n\nIn Slack, react with ✅ or ❌ to indicate the status of your workflow."
  },
  {
    "objectID": "index.html#test-suite",
    "href": "index.html#test-suite",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "Test suite",
    "text": "Test suite\nThis initial “hello world” workflow is cute, but not very useful. Let’s edit the workflow to run our test suite for us automatically!\nR\nuse devtools::test() to run just the tests, or devtools::check() to run all checks for CRAN.\n\n\n\ntest R .github/workflows/ci.yml\n\nname: CI\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n      R_KEEP_PKG_SOURCE: yes\n    steps:\n      - uses: actions/checkout@v3\n      - uses: r-lib/actions/setup-r@v2\n        with:\n          use-public-rspm: true\n      - uses: r-lib/actions/setup-r-dependencies@v2\n        with:\n          extra-packages: any::rcmdcheck\n          needs: check\n          working-directory: bionitio\n      - name: Check\n        uses: r-lib/actions/check-r-package@v2\n        with:\n          args: 'c(\"--no-manual\", \"--as-cran\")'\n          working-directory: bionitio\n\n\n\n\n\n\n\n\nRepo tree\n\n\n\nThe r-lib actions assume that the top level of your repo is the same as the top level of your R package. If that’s not the case, you’ll need to specify the working-directory.\nFor my example project, bionitio-r is the top level of the git repo, and from there the R package resides in bionitio:\nbionitio-r\n├── README.md\n├── .github\n│   └── workflows\n│       └── ci.yml\n├── bionitio\n│   ├── DESCRIPTION\n│   ├── R\n│   │   ├── bionitio.R\n│   │   └── file_utils.R\n│   └── tests\n│       ├── testthat\n│       │   └── test-stats.R\n│       └── testthat.R\n\n\n\n\n\n\n\n\nIgnore check dir\n\n\n\nThe check-r-package action creates files in /package/check/. We don’t want git to track them, so we need to add the check dir to the gitignore file:\n\n\n\nR .gitignore\n\n.Rproj.user\n.Rhistory\n.RData\n.Ruserdata\ncheck/\n\n\n\n\nPython\nUse pytest to run the test suite.\n\n\n\ntest Py .github/workflows/ci.yml\n\nname: CI\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python 3.11\n      uses: actions/setup-python@v3\n      with:\n        python-version: \"3.11\"\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install pytest\n        if [ -f requirements.txt ]; then\n            pip install -r requirements.txt\n        fi\n    - name: Test with pytest\n      run: |\n        pytest .\n\n\nIn each of these workflows, the action checks out the repo, installs R or Python, installs the dependencies of the package, then runs the tests. If any of your tests fail, the whole actions workflow will fail too.\n\n\n\n\n\n\nDependencies\n\n\n\nHave you been keeping track of your package’s dependencies? Be sure to add them according to the instructions below! If you need a certain minimum version of a package, you can specify the version number with PACKAGE &gt;= VERSION, e.g. biopython &gt;= 1.70.\nR imports\nIf your package depends on any other packages, you need to add them to DESCRIPTION under Imports for required dependencies or Suggests if only needed for some functions. bionitio-r needs two R packages, so they’re listed like so:\n\n\n\nbionitio/DESCRIPTION\n\nPackage: bionitio\nType: Package\nTitle: Calculate FASTA statistics\nVersion: 0.1.0\nDescription: This package reads in one or more input FASTA files and calculates\n    a variety of statistics.\nLicense: MIT + file LICENSE\nImports:\n    seqinr,\n    logging\nSuggests:\n    devtools,\n    testthat\n\n\nPython requirements\nIf your package depends on any other packages, you need to add them to requirements.txt. bionitio-python needs one Python package listed like so:\n\n\n\nrequirements.txt\n\nbiopython &gt;= 1.70\n\n\n\n\n\n\n\n\n\n\n\nTesting with CI\n\n\n\nIn your ci branch, modify your CI workflow to run the test suite, then commit and push your changes. Does the CI workflow succeed or fail?\nYou may get failures if you haven’t been running your unit tests or tracking dependencies as you develop your code base. Go to the workflow log file and expand the test step to see why it failed. Take a few minutes to open issues for each test that failed. If the problem is with your dependencies, fix them now.\nReact to the slack message with ✅ when you’re finished opening issues, fixing dependencies, or now if the workflow completed successfully.\n\n\nWorkflow status badges\nEach Actions workflow has a status badge that indicates whether the action is passing or failing. You may have come across status badges in GitHub README files of packages you use. Putting a CI status badge in the README file is a popular way for project maintainers to prominently display that CI is set up and it’s working!\n\n\n\n\n\n\nAdd the workflow status badge to your README\n\n\n\nUnder the Actions tab, click the name of the workflow (e.g. ci), click the triple dots menu (...) in the upper right corner, and select Create status badge.\nIn the pop-up menu, click Copy status badge Markdown, paste it into your README.md file, then commit and push your change on the ci branch.\nReact to the slack message with ✅ when you’re finished.\n\n\n\n\nNow anyone who takes a look at your README file will see that your project uses continuous integration!"
  },
  {
    "objectID": "index.html#lint-and-style-code",
    "href": "index.html#lint-and-style-code",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "Lint and style code",
    "text": "Lint and style code\nMany large software projects follow a specific coding style guide to make sure their code base is consistent and easy to read.\n\nGood coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread.\n– The Tidyverse Style Guide\n\nA linter checks your code to make sure you conform to a style guide and raises warnings if your code doesn’t conform. A code formatter or styler modifies your code to make it conform to a style guide. There is a lot of overlap in the problems that linters and formatters can catch. However, linters additionally warn about not only style problems but also more serious problems like syntax errors.\n\n\nlanguage\nlinter\nformatter\n\n\n\nR\nlinter\nstyler\n\n\nPython\nflake8\nblack\n\n\n\nWhen adding these tools to CI, make sure you run the formatter before the linter, so the linter will only complain about problems that the formatter can’t fix. Since the code formatter modifies our code, we will also need to commit and push the code changes using the GitHub Actions bot as the author.\nR\n\n\n\nstyle R .github/workflows/ci.yml\n\nname: CI\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\nenv:    # configure environment variables for git commits\n  actor: \"41898282+github-actions[bot]\"\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n      R_KEEP_PKG_SOURCE: yes\n    steps:\n      - uses: actions/checkout@v3\n      - uses: r-lib/actions/setup-r@v2\n        with:\n          use-public-rspm: true\n      - uses: r-lib/actions/setup-r-dependencies@v2\n        with:  # also install styler & lintr\n          extra-packages: any::rcmdcheck, any::styler, any::lintr\n          needs: check\n          working-directory: bionitio\n      - name: Configure git # use the environment variable we set above\n        run: |\n          git config --local user.email \"${actor}@users.noreply.github.com\"\n          git config --local user.name \"$actor\"\n      - name: Check\n        uses: r-lib/actions/check-r-package@v2\n        with:\n          args: 'c(\"--no-manual\", \"--as-cran\")'\n          working-directory: bionitio\n      - name: Style & lint\n        run: |\n            styler::style_dir(\".\")\n            lintr::lint_dir(\".\")\n        shell: Rscript {0}\n      - name: Commit and push changes\n        run: |\n          git add .\n          git commit -m \"🎨 Style code\" || echo \"No changes to commit\"\n          git push\n\n\nPython\n\n\n\nstyle Py .github/workflows/ci.yml\n\nname: CI\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\nenv:    # configure environment variables for git commits\n  actor: \"41898282+github-actions[bot]\"\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python 3.11\n      uses: actions/setup-python@v3\n      with:\n        python-version: \"3.11\"\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install pytest black flake8 # also install black & flake8\n        if [ -f requirements.txt ]; then\n            pip install -r requirements.txt\n        fi\n    - name: Configure git  # use the environment variable we set above\n      run: |\n        git config --local user.email \"${actor}@users.noreply.github.com\"\n        git config --local user.name \"$actor\"\n    - name: Test\n      run: |\n        pytest .\n    - name: Format & lint\n      run: |\n        black . # first run black, then run flake8\n        flake8 --extend-ignore E203 --max-line-length 88 .\n    - name: Commit and push changes\n      run: |\n        git add .\n        git commit -m \"🎨 Style code\" || echo \"No changes to commit\"\n        git push\n\n\n\n\n\n\n\n\nNote\n\n\n\nflake8 is not 100% compatible with black by default. Here we direct flake8 to ignore one of its errors (--extend-ignore E203) and increase the maximum allowed line length (--max-line-length 88) to make flake8 compatible with black.\n\n\nThere are several key changes we made to the workflow to make sure our styling and linting would work:\n\nSet a global environment variable called actor with the username of the GitHub Actions bot.\nConfigure the git username and email to point to the GitHub Actions bot, using the environment variable we created as above.\nInstall additional dependencies for linting and formatting the code.\nRun the code formatter and linter.\nCommit any changes and push to origin.\n\n\n\n\n\n\n\nStyle & lint your code\n\n\n\nModify your workflow to style and lint your code, and see what happens when you push it to GitHub.\nDoes the linter raise any errors? If so, take a moment to open issues for the errors you need to fix. React to the slack message with ✅ when you’re finished opening issues or now if your code is already lint-free.\n\n\n\n\n\n\n\n\nAre your tests failing?\n\n\n\nIf you have some failing tests, the workflow will fail before it gets to the lint & style step. You can temporarily comment-out any failing steps with hashes (#) so you can continue through this tutorial, but don’t forget to uncomment these lines later!"
  },
  {
    "objectID": "index.html#code-coverage",
    "href": "index.html#code-coverage",
    "title": "Developing Bioinformatics Software: Continuous Integration",
    "section": "Code coverage",
    "text": "Code coverage\nCode coverage is the percentage of your source code that is covered by unit tests. Generally the higher the code coverage, the better. It can be a useful metric to see where there are holes in your tests.\nCodecov.io is a free tool for open source projects that pairs nicely with GitHub Actions for generating code coverage reports! Let’s set it up now.\n\n\n\n\n\n\nlogin to codecov\n\n\n\nGo to https://about.codecov.io/ and Login with GitHub. If this is the first time you’re connecting Codecov and GitHub, you may need to grant Codecov permission to read your repositories.\nOnce you’re logged in, you should see a list of all your GitHub repos (and maybe also those of any organizations you’re a member of). Scroll down to your repo for this class and click setup repo.\n\n\n\nFollow the instructions on the next page to set up code coverage for your repo. Just do Step 1 and Step 2 now; we need to make some custom modifications to Step 3 for our projects.\n\n\n\n\n\n\n\nWarning\n\n\n\nYour CODECOV_TOKEN should be kept secret. Don’t paste it anywhere except for in your repository’s Actions secrets.\n\n\n\n\n\n\n\n\nCodecov setup\n\n\n\nReact to the message on Slack with 1️⃣ for Step 1 and 2️⃣ for Step 2 once you complete them. Don’t do the other Steps yet.\n\n\nAdd codecov to the workflow\nWe’ll need to make sure the test suite generates a report that codecov can ingest.\nPython\nFor Python, you’ll need to install an additonal plugin called pytest-cov and set the --cov flag when you run pytest. You can paste the codecov step anywhere after the test step of your workflow.\nRunning pytest with --cov generates an xml file. You don’t want to track that with git, so add coverage.xml to your gitignore file:\n\n\n\nPy .gitignore\n\n__pycache__/\ncoverage.xml\n\n\n\n\n\ncodecov Py .github/workflows/ci.yml\n\nname: CI\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\nenv:\n  actor: \"41898282+github-actions[bot]\"\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python 3.11\n      uses: actions/setup-python@v3\n      with:\n        python-version: \"3.11\"\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install pytest pytest-cov black flake8 # add pytest-cov plugin\n        if [ -f requirements.txt ]; then\n            pip install -r requirements.txt\n        fi\n    - name: Configure git\n      run: |\n        git config --local user.email \"${actor}@users.noreply.github.com\"\n        git config --local user.name \"$actor\"\n    - name: Test\n      run: |\n        pytest --cov=bionitio tests/ # specify your package & test paths\n    - name: Upload coverage reports to Codecov\n      uses: codecov/codecov-action@v3\n    - name: Format & lint\n      run: |\n        black .\n        flake8 --extend-ignore E203 --max-line-length 88 .\n    - name: Commit and push changes\n      run: |\n        git add .\n        git commit -m \"🎨 Style code\" || echo \"No changes to commit\"\n        git push\n\n\nR\nFor R, the covr package runs the test suite, generates a report, and uploads it to codecov all with one function. You don’t need codecov’s Action as in the Python workflow, because covr handles that for you.\n\n\n\ncodecov R .github/workflows/ci.yml\n\nname: CI\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\nenv:\n  actor: \"41898282+github-actions[bot]\"\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n      R_KEEP_PKG_SOURCE: yes\n    steps:\n      - uses: actions/checkout@v3\n      - uses: r-lib/actions/setup-r@v2\n        with:\n          use-public-rspm: true\n      - uses: r-lib/actions/setup-r-dependencies@v2\n        with:\n          extra-packages: any::rcmdcheck, any::styler, any::lintr any::covr\n          needs: check\n          working-directory: bionitio\n      - name: Configure git\n        run: |\n          git config --local user.email \"${actor}@users.noreply.github.com\"\n          git config --local user.name \"$actor\"\n      - name: Check\n        uses: r-lib/actions/check-r-package@v2\n        with:\n          args: 'c(\"--no-manual\", \"--as-cran\")'\n          working-directory: bionitio\n      - name: Style & lint\n        run: |\n            styler::style_dir(\".\")\n            lintr::lint_dir(\".\")\n        shell: Rscript {0}\n      - name: Commit and push changes\n        run: |\n          git add .\n          git commit -m \"🎨 Style code\" || echo \"No changes to commit\"\n          git push\n      - name: Test coverage\n        run: covr::codecov(path = \"bionitio\")  # set your package path here\n        shell: Rscript {0}\n\n\nOnce your modified CI workflow has completed successfully with the new codecov step, you’ll be able to view coverage reports for your repo on codecov.io and see them in your pull requests. However, if your tests aren’t passing, codecov won’t be able to generate a report.\n\n\n\n\n\n\n\nCodecov report\n\n\n\nReact to the Slack message with:\n\n✅ once your CI workflow completes successfully with codecov and you can see the coverage report.\n🔨 if you need to fix your tests before the workflow can complete.\n\n\n\nCodecov status badge\nCodecov has a nifty status badge that we can display in our README file too.\nCopy and paste the following into your README.md, then replace GITHUB_USERNAME and GITHUB_REPO in both the image and link URLs.\n[![codecov](https://codecov.io/gh/GITHUB_USERNAME/GITHUB_REPO/branch/main/graph/badge.svg)](https://codecov.io/gh/GITHUB_USERNAME/GITHUB_REPO)\nHere’s what my project README looks like now:\n\n\n\nREADME.md\n\n# bionitio-python\n\n[![ci](https://github.com/kelly-sovacool/bionitio-python/actions/workflows/ci.yml/badge.svg)](https://github.com/kelly-sovacool/bionitio-python/actions/workflows/ci.yml)\n[![codecov](https://codecov.io/gh/kelly-sovacool/bionitio-python/branch/main/graph/badge.svg)](https://codecov.io/gh/kelly-sovacool/bionitio-python)\n\n\n\nThe color of the badge changes from red to green as coverage increases. If your tests aren’t passing or the codecov upload action didn’t work, it will display unknown as the coverage for now.\n\n\n\n\n\n\nCodecov badge\n\n\n\nReact to the Slack message with ✅ once you’ve added the codecov badge to your README.\n\n\nInterpreting code coverage\nGenerally, higher code coverage is better. However, a code coverage of 100% doesn’t guarantee that your package doesn’t have any bugs, it only means that every line of code is run at least once by your test suite. Not all code strictly needs to be tested; very few software projects have a code coverage anywhere close to 100%. Focus on writing unit tests that test your assumptions about how your code works, and prioritize testing the most important components of your project."
  }
]